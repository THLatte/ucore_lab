#lab4 实验报告
计22 徐天宇

## 练习1：分配并初始化一个进程控制块（需要编码）

```
需要补充的函数为alloc_proc()。

函数中已经完成了一个新的proc_struct的建立（kmalloc函数）。
按照注释中的要求，依次将下列变量进行相应的初始化：
state：刚刚创建的新线程还未进入运作模式，初始化为PROC_UNINIT；
pid：该线程刚刚创建还没有分配进程号，初始化为-1；
runs：该线程刚刚被创建，还没有开始运行，初始化为0；
kstack：该线程刚刚被创建，还没有分配内核栈，初始化为0；
need_resched：该线程还需要做其他的工作，不希望被切换，初始化为0；
parent：还没有确定该线程的父进程，初始化为NULL；
mm：还没有确定该线程占用的存储空间信息，初始化为NULL；
context：由于该线程尚未参与任何的进程切换过程，用memset将其初始化为0；
tf：该线程尚未参与任何中断过程，将其初始化为NULL；
cr3：由于创建的是内核线程，所以将其初始化为内核虚拟空间页目录表首地址boot_cr3；
flags：初始化为0；
name：该线程的名字尚未确定，于是初始化为0。
```

### 与标准答案的区别

```
按照注释中的说明来编写的代码，期初对于name的初始化是proc->name = ""，结果程序无法运行，更改为用memset来初始化后程序能够正确运行，此时与标准答案已基本没有差别。
```

### 请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

```
context：进程的上下文，用于进程的切换时保存进程运行至切换时的寄存器信息。在本实验中，主要被switch.S中定义的switch_to函数所使用来完成进程之间的切换。
tf：进程的中断帧的指针。用于在进程被中断的时候保存进程的状态（各寄存器的值），以便于在中断结束时能够正确地恢复被打断的进程的信息。在本实验中由于没有设置用户态进程，所以该变量暂时没有发挥作用，只是在do_fork函数中被赋给了新的proc。
```

## 练习2：为新创建的内核线程分配资源（需要编码）

```
需要补充的函数为do_fork()。

按照注释中的讲解来补充。
首先调用alloc_proc()函数来分配一个新的内核线程控制块，如果分配失败则直接返回；
然后调用setup_kstack()函数来分配一个内核栈，如果失败则直接清理掉分配的控制块资源后返回；
之后调用copy_mm()函数来将current线程中的内存信息复制给新进程或与子进程共享，如果失败则清理掉分配的内核栈信息和控制块信息后返回；
调用函数copy_thread()函数来设立新进程的tf和context信息；
然后关中断，将新建立的内核线程信息添加到hash_list和proc_list中，并增加总线程数目，开中断。	
最后调用wakeup_proc()函数唤醒这一新线程，让其进入runnable状态。
至此成功完成新线程的建立，返回新线程的id。	
```

### 与标准答案不同

```
在增加总线程数目后，我增加了一个cprintf信息，输出目前的总线程数。该语句已被注释掉
```

### 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

```
是的。do_fork()函数调用了get_pid()函数，该函数通过遍历整个proc_list列表已确定分配一个不和任何已有进程重复的pid。
```

## 练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。（无编码工作）

```
该函数首先查看传入的参数时候是现在正在运行的进程，如果是的话则不做任何处理，如果不是则进行进程切换。
首先关中断，然后将current设置为proc，意味进程切换，现在运行的进程是proc。然后更改内核栈指针使其指向新进程的内核栈栈顶，完成内核栈的切换。之后将cr3设置为next进程的页目录表起始地址，完成页表的切换。最后调用switch_to函数将旧进程的寄存器值保存，将新进程的寄存器值取出，从而完成新进程运行环境的建立。至此完成进程的切换。
```

### 在本实验的执行过程中，创建且运行了几个内核线程？

```
2个。
从整个程序的输出结果来看，一共出现了2个内核线程ide0和ide1，分别是idleproc和initproc。
```

### 语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用?请说明理由

```
作用是关中断和开中断。
由于进程切换是不允许被打断的，故调用这两个函数分别在切换开始前清除掉允许中断标志irg，在切换结束后恢复允许中断标志irg。
```
